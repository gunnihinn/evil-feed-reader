<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Programming in the 21st Century</title>
<link rel="self" href="http://prog21.dadgum.com/atom.xml"/>
<link rel="alternate" href="http://prog21.dadgum.com/"/>
<id>http://prog21.dadgum.com/</id>
<updated>2017-01-04T00:00:00-06:00</updated>
<entry>
<title>So Long, Prog21</title>
<link rel="alternate" type="text/html" href="http://prog21.dadgum.com/229.html"/>
<id>http://prog21.dadgum.com/229.html</id>
<published>2017-01-04T00:00:00-06:00</published>
<updated>2017-01-04T00:00:00-06:00</updated>
<author><name>James Hague</name></author>
<content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>I always intended "Programming in the 21st Century" to have a limited run. I knew since the <a href="http://prog21.dadgum.com/56.html">Recovering Programmer</a> entry from January 1, 2010, that I needed to end it. It just took a while.</p><p>And now, an explanation.</p><p>I started this blog to talk about issues tangentially related to programming, about soft topics like creativity and inspiration and how code is a medium for implementing creative visions. Instead I worked through more technical topics that I'd been kicking around over the years. That was fun! <a href="http://prog21.dadgum.com/23.html">Purely Functional Retrogames</a> is something I would have loved to read in 1998. More than once I've googled around and ended up back at one of my essays.</p><p>As I started shifting gears and getting back toward what I originally wanted to do, there was one thing that kept bothering me: the word <i>programming</i> in the title.</p><p>I don't think of myself as a programmer. I write code, and I often enjoy it when I do, but that term <i>programmer</i> is both limiting and distracting. I don't want to program for its own sake, not being interested in the overall experience of what I'm creating. If I start thinking too much about programming as a distinct entity then I lose sight of that. Now that I've exhausted what I wanted to write about, I can clear those topics out of my head and focus more on using technology to make fun things.</p><p>Thanks for reading!</p><p>It's hard to sum up 200+ articles, but here's a start. This is not even close to a full index. See the <a href="http://prog21.dadgum.com/archives.html">archives</a> if you want everything. (There are some <a href="http://prog21.dadgum.com/32.html">odd</a> bits in there.)</p><h2>widely linked</h2><ul>
<li><a href="http://prog21.dadgum.com/116.html">Things That Turbo Pascal is Smaller Than</a></li>
<li><a href="http://prog21.dadgum.com/154.html">Do You Really Want to be Doing This When You're 50?</a></li>
<li><a href="http://prog21.dadgum.com/177.html">Organizational Skills Beat Algorithmic Wizardry</a></li>
<li><a href="http://prog21.dadgum.com/203.html">Retiring Python as a Teaching Language</a></li>
<li><a href="http://prog21.dadgum.com/210.html">Computer Science Courses that Don't Exist, But Should</a></li>
</ul><h2>popular</h2><ul>
<li><a href="http://prog21.dadgum.com/19.html">Five Memorable Books About Programming</a></li>
<li><a href="http://prog21.dadgum.com/29.html">A Spellchecker Used to Be a Major Feat of Software Engineering</a></li>
<li><a href="http://prog21.dadgum.com/30.html">Want to Write a Compiler? Just Read These Two Papers.</a></li>
<li><a href="http://prog21.dadgum.com/40.html">On Being Sufficiently Smart</a></li>
<li><a href="http://prog21.dadgum.com/61.html">Optimizing for Fan Noise</a></li>
<li><a href="http://prog21.dadgum.com/74.html">Free Your Technical Aesthetic from the 1970s</a></li>
<li><a href="http://prog21.dadgum.com/80.html">Advice to Aimless, Excited Programmers</a></li>
<li><a href="http://prog21.dadgum.com/87.html">Write Code Like You Just Learned How to Program</a></li>
<li><a href="http://prog21.dadgum.com/93.html">Don't Distract New Programmers with OOP</a></li>
<li><a href="http://prog21.dadgum.com/123.html">Recovering From a Computer Science Education</a></li>
<li><a href="http://prog21.dadgum.com/128.html">Don't Fall in Love With Your Technology</a></li>
<li><a href="http://prog21.dadgum.com/129.html">A Complete Understanding is No Longer Possible</a></li>
<li><a href="http://prog21.dadgum.com/130.html">Solving the Wrong Problem</a></li>
<li><a href="http://prog21.dadgum.com/132.html">This is Why You Spent All that Time Learning to Program</a></li>
<li><a href="http://prog21.dadgum.com/139.html">We Who Value Simplicity Have Built Incomprehensible Machines</a></li>
<li><a href="http://prog21.dadgum.com/142.html">Your Coding Philosophies are Irrelevant</a></li>
<li><a href="http://prog21.dadgum.com/143.html">The Silent Majority of Experts</a></li>
<li><a href="http://prog21.dadgum.com/149.html">Hopefully More Controversial Programming Opinions</a></li>
<li><a href="http://prog21.dadgum.com/179.html">How much memory does malloc(0) allocate?</a></li>
</ul><h2>on creativity</h2><ul>
<li><a href="http://prog21.dadgum.com/46.html">The Pure Tech Side is the Dark Side</a></li>
<li><a href="http://prog21.dadgum.com/58.html">Flickr as a Business Simulator</a></li>
<li><a href="http://prog21.dadgum.com/69.html">How to Think Like a Pioneer</a></li>
<li><a href="http://prog21.dadgum.com/72.html">What Do People Like?</a></li>
<li><a href="http://prog21.dadgum.com/89.html">Accidental Innovation, Part 1</a></li>
<li><a href="http://prog21.dadgum.com/94.html"> If You're Not Gonna Use It, Why Are You Building It?</a></li>
<li><a href="http://prog21.dadgum.com/107.html">It's Like That Because It Has Always Been Like That</a></li>
<li><a href="http://prog21.dadgum.com/164.html">Trapped by Exposure to Pre-Existing Ideas</a></li>
<li><a href="http://prog21.dadgum.com/193.html">Get Good at Idea Generation</a></li>
<li><a href="http://prog21.dadgum.com/197.html">You Can't Sit on the Sidelines and Become a Philosopher</a></li>
<li><a href="http://prog21.dadgum.com/202.html">The Software Developer's Sketchbook</a></li>
<li><a href="http://prog21.dadgum.com/199.html">Design is Expensive</a></li>
<li><a href="http://prog21.dadgum.com/208.html">Why Doesn't Creativity Matter in Tech Recruiting?</a></li>
</ul><h2>others that I like</h2><ul>
<li><a href="http://prog21.dadgum.com/8.html">Deriving Forth</a></li>
<li><a href="http://prog21.dadgum.com/50.html">Tales of a Former Disassembly Addict</a></li>
<li><a href="http://prog21.dadgum.com/66.html">Living Inside Your Own Black Box</a></li>
<li><a href="http://prog21.dadgum.com/71.html">Tricky When You Least Expect It</a></li>
<li><a href="http://prog21.dadgum.com/137.html">The Most Important Decisions are Non-Technical</a></li>
<li><a href="http://prog21.dadgum.com/145.html">Things to Optimize Besides Speed and Memory</a></li>
<li><a href="http://prog21.dadgum.com/148.html">All that Stand Between You and a Successful Project are 500 Experiments</a></li>
<li><a href="http://prog21.dadgum.com/159.html">The UNIX Philosophy and a Fear of Pixels</a></li>
<li><a href="http://prog21.dadgum.com/160.html">Dangling by a Trivial Feature</a></li>
<li><a href="http://prog21.dadgum.com/161.html">Documenting the Undocumentable</a></li>
<li><a href="http://prog21.dadgum.com/190.html">You Don't Want to Think Like a Programmer</a></li>
<li><a href="http://prog21.dadgum.com/194.html">You Don't Read Code, You Explore It</a></li>
<li><a href="http://prog21.dadgum.com/209.html">If You Haven't Done It Before, All Bets Are Off</a></li>
<li><a href="http://prog21.dadgum.com/212.html">What Can You Put in a Refrigerator?</a></li>
<li><a href="http://prog21.dadgum.com/214.html">The Same User Interface Mistakes Over and Over</a></li>
<li><a href="http://prog21.dadgum.com/221.html">Fun vs. Computer Science</a></li>
</ul><h2>Erlang</h2><ul>
<li><a href="http://prog21.dadgum.com/1.html">A Deeper Look at Tail Recursion in Erlang</a></li>
<li><a href="http://prog21.dadgum.com/22.html">My Road to Erlang</a></li>
<li><a href="http://prog21.dadgum.com/16.html">Garbage Collection in Erlang</a></li>
<li><a href="http://prog21.dadgum.com/43.html">How to Crash Erlang</a></li>
<li><a href="http://prog21.dadgum.com/64.html">Eleven Years of Erlang</a></li>
<li><a href="http://prog21.dadgum.com/70.html">A Ramble Through Erlang IO Lists</a></li>
<li><a href="http://prog21.dadgum.com/81.html">A Concurrent Language for Non-Concurrent Software</a></li>
<li><a href="http://prog21.dadgum.com/127.html">A Peek Inside the Erlang Compiler</a></li>
<li><a href="http://prog21.dadgum.com/220.html">Evolution of an Erlang Style</a></li>
</ul><h2>retro</h2><ul>
<li><a href="http://prog21.dadgum.com/45.html">A Personal History of Compilation Speed</a></li>
<li><a href="http://prog21.dadgum.com/52.html">Slow Languages Battle Across Time</a></li>
<li><a href="http://prog21.dadgum.com/68.html">How Much Processing Power Does it Take to be Fast?</a></li>
<li><a href="http://prog21.dadgum.com/104.html">8-Bit Scheme: A Revisionist History</a></li>
<li><a href="http://prog21.dadgum.com/173.html">Stumbling Into the Cold Expanse of Real Programming</a></li>
<li><a href="http://prog21.dadgum.com/181.html">Why Do Dedicated Game Consoles Exist?</a></li>
<li><a href="http://prog21.dadgum.com/198.html">Lost Lessons from 8-Bit BASIC</a></li>
<li><a href="http://prog21.dadgum.com/201.html">Programming Modern Systems Like It Was 1984</a></li>
</ul><p>Also see the <a href="http://prog21.dadgum.com/228.html">previous entry</a> for all of the functional programming articles.</p><p><a href="http://dadgum.com/james/performance.html">Programming as if Performance Mattered</a> is something I wrote in 2004 which used to be linked from every prog21 entry.</p></div></content>
</entry>
<entry>
<title>Writing Video Games in a Functional Style</title>
<link rel="alternate" type="text/html" href="http://prog21.dadgum.com/228.html"/>
<id>http://prog21.dadgum.com/228.html</id>
<published>2016-12-29T00:00:00-06:00</published>
<updated>2016-12-29T00:00:00-06:00</updated>
<author><name>James Hague</name></author>
<content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>When I started this blog in 2007, a running theme was "Can interactive experiences like video games be written in a functional style?" These are programs heavily based around mutable state. They evolve, often drastically, during development, so there isn't a perfect up-front design to architect around. These were issues curiously avoided by the functional programming proponents of the 1980s and 1990s.</p><p>It's still not given much attention in 2016 in either. I regularly see excited tutorials about mapping and folding and closures and immutable variables, and even JavaScript has these things now, but there's a next step that's rarely discussed and much more difficult: how to keep the benefits of immutability in large and messy programs that could gain the most from functional solutions--like video games.</p><p>Before getting to that, here are the more skeptical functional programming articles I wrote, so it doesn't look like I'm a raving advocate:</p><ul>
<li><a href="http://prog21.dadgum.com/3.html">Admitting that Functional Programming Can Be Awkward</a></li>
<li><a href="http://prog21.dadgum.com/18.html">Back to the Basics of Functional Programming</a></li>
<li><a href="http://prog21.dadgum.com/31.html">Functional Programming Went Mainstream Years Ago</a></li>
<li><a href="http://prog21.dadgum.com/38.html">Puzzle Languages</a></li>
<li><a href="http://prog21.dadgum.com/41.html">Let's Take a Trivial Problem and Make it Hard</a></li>
<li><a href="http://prog21.dadgum.com/54.html">Functional Programming Doesn't Work (and what to do about it)</a></li>
</ul><p>I took a straightforward, arguably naive, approach to interactive functional programs: no monads (because I didn't understand them), no functional-reactive programming (ditto, plus all implementations had severe performance problems), and instead worked with the basic toolkit of function calls and immutable data structures. It's completely possible to write a video game (mostly) in that style, but it's not a commonly taught methodology. "Purely Functional Retrogames" has most of the key lessons, but I added some additional techniques later:</p><ul>
<li><a href="http://prog21.dadgum.com/23.html">Purely Functional Retrogames</a> (4 parts)</li>
<li><a href="http://prog21.dadgum.com/131.html">Turning Your Code Inside Out</a></li>
<li><a href="http://prog21.dadgum.com/189.html">A Worst Case for Functional Programming?</a></li>
<li><a href="http://prog21.dadgum.com/216.html">Messy Structs/Classes in a Functional Style</a></li>
<li><a href="http://prog21.dadgum.com/207.html">Reconsidering Functional Programming</a></li>
</ul><p>The bulk of my experience came from rewriting a 60fps 2D shooter in mostly-pure Erlang. I wrote about it in <a href="http://prog21.dadgum.com/157.html">An Outrageous Port</a>, but there's not much detail. It really needed to be a multi-part series with actual code.</p><p>For completeness, here are the other articles that directly discuss FP:</p><ul>
<li><a href="http://prog21.dadgum.com/14.html">Functional Programming Archaeology</a></li>
<li><a href="http://prog21.dadgum.com/36.html">Accidentally Introducing Side Effects into Purely Functional Code</a></li>
<li><a href="http://prog21.dadgum.com/73.html">Explaining Functional Programming to Eight-Year-Olds</a></li>
<li><a href="http://prog21.dadgum.com/79.html">Erlang vs. Unintentionally Purely Functional Python</a></li>
<li><a href="http://prog21.dadgum.com/115.html">Starting in the Middle</a></li>
<li><a href="http://prog21.dadgum.com/138.html">You, Too, Can Be on the Cutting Edge of Functional Programming Research</a></li>
<li><a href="http://prog21.dadgum.com/176.html">Tips for Writing Functional Programming Tutorials</a></li>
<li><a href="http://prog21.dadgum.com/180.html">Purely Functional Photoshop</a></li>
</ul><p>If I find any I missed, I'll add them.</p></div></content>
</entry>
<entry>
<title>Progress Bars are Surprisingly Difficult</title>
<link rel="alternate" type="text/html" href="http://prog21.dadgum.com/227.html"/>
<id>http://prog21.dadgum.com/227.html</id>
<published>2016-12-21T00:00:00-06:00</published>
<updated>2016-12-21T00:00:00-06:00</updated>
<author><name>James Hague</name></author>
<content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>We've all seen progress bars that move slowly for twenty minutes, then rapidly fill up in the last 30 seconds. Or the reverse, where a once speedy bar takes 50% of the time covering the last few pixels. And bars that occasionally jump backward in time are not the rarity you'd expect them to be.</p><p>Even this past month, when I installed the macOS Sierra update, the process completed when the progress bar was only two-thirds full. DOOM 2016 has a circular progress meter for level loads, with the percent-complete in the center. It often sits for a while at 0%, gets stuck at 74% and 99%, and sometimes finishes in the 90s before reaching 100%.</p><p>Clearly this is not a trivial problem, or these quirks would be behind us.</p><p>Conceptually, a perfect progress bar is easy to build. All you need to know is exactly how long the total computation will take, then update the bar in its own thread so it animates smoothly. Simple! Why do developers have trouble with this? Again, all you need to know is <i>exactly how long</i>...</p><p>Oh.</p><p>You could time it with a stopwatch and use that value, but that assumes your system is the standard, and that other people won't have faster or slower processors, drives, or internet connections. You could run a little benchmark and adjust the timing based on that, but there are too many factors. You could refine the estimate mid-flight, but this is exactly the road that leads to the bar making sudden jumps into the past. It's all dancing around that you can't know ahead of time exactly how long it should take for the progress bar to go from empty to full.</p><p>There's a similar problem in process scheduling, where there are a number of programs to run sequentially in batch mode. One program at a time is selected to run to completion, then the next. If the goal is to have the lowest average time for programs being completed, then best criteria for choosing the next program to run is the one with the shortest execution time (see <a href="https://en.wikipedia.org/wiki/Shortest_job_next">shortest job next</a>). But this requires knowing how long each program will take before running it, and that's not possible in the general case.</p><p>And so the perfect progress bar is forever out of reach, but they're still useful, as established by Brad Allan Meyers in his 1985 paper ("The importance of percent-done progress indicators for computer-human interfaces"). But "percent-done" of what? It's easy to map the loading of a dozen similarly sized files to an overall percentage complete. Not so much when all kinds of downloading and local processing is combined together into a single progress number. At that point the progress bar loses all meaning except as an indication that there's some sort of movement toward a goal, and that mostly likely the application hasn't hasn't locked up.</p><p>(If you liked this, you might enjoy <a href="http://prog21.dadgum.com/163.html">An Irrational Fear of Files on the Desktop</a>.)</p></div></content>
</entry>
</feed>